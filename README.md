# Cpp-class-4-2
### 虚基类
- 虚基类构造函数必须只被调用一次。
- 规定将在建立对象时所指定的类称为最直接派生类。虚基类子对象是由最直接派生类的构造函数通过调用虚基类的构造函数进行初始化的。
- 只有用于建立对象的那个派生类的构造函数调用虚基类的构造函数，而该派生类的基类中所列出的对这个虚基类的构造函数调用在执行中被忽略。
- 
```

```
### 基类与派生类的转化
- 
- 
```
	Person* p[4];
	p[0]=new Person(1);
	p[1]=new Student(2,101);
	p[2]=new Teacher(3,1001);
	p[3]=new Assistant(4,1,1,1000);
	for(int i=0;i<4;i++)
		p[i]->print();//绑定Person的print(),编译期间，只检测类型
    //不灵活
```
## 多态
### 多态的实现
- 静态多态是指在程序编译时系统就能够确定要调用的是哪个函数，因此这种多态也被称为编译时多态。通过函数的重载来实现
```
                   A  objA;
                   objA.get(‘a’);
                   objA.get (5);
```
- 动态多态性是指程序在编译时并不能确定要调用的函数，直到运行时系统才能动态地确定操作所针对的具体对象，它又被称为运行时多态。

`virtual void print(){cout << "person::id"<<id <<endl;}//虚函数`
- virtual 函数类型 函数名（参数列表）;

 是否实现了动态多态:
     相同的函数名
     相同的参数列表
     相同的函数类型
     
1. virtual只能使用在类定义的函数原型声明中，不能在成员函数实现的时候使用，也不能用来限定类外的普通函数。
2. virtual具有继承性，在派生类覆盖基类虚成员函数时，既可以使用virtual，也可以不用virtual来限定，二者没有差别，默认派生类中的重写函数是具有virtual的。


# 4-4

## 虚析构函数
### 

```
//源文件：虚析构函数.cpp
TwoDShape*p;
p=new Rectangle(...);

delete p;//执行绑定TwoDShape析构函数,不执行Rectangle析构
//    ~TwoDShape()
//    {
//        cout <<"destruct a TwoDShape" <<endl;
//    }
```
- 虚析构函数
```
    virtual ~TwoDShape(){...}
```
## 纯虚函数
`virtual void getArea()=0;//纯虚函数，无函数体，派生类中实现`
- 抽象类:有一个或多个纯虚函数
抽象类使用时：
1. 不能定义抽象类对象  TwoDShape obj（...）
2. 可以定义抽象类指针或引用 

# 小结
1．派生类的某些功能与基类同名，但是不同的派生类彼此之间又有不同，可以利用虚函数实现同名函数在不同类中的不同功能。 

2．基类中的某些功能本身并没有具体的作用，一般把这种函数设计为纯虚函数，它的存在是为了提供给多个派生类一个统一的访问接口，具体功能是在派生类中根据实际对象的要求而实现的。 
- 利用动态多态技术，可以使程序代码更加简洁，可以实现不同类型的对象针对同一指令产生不同的响应。








